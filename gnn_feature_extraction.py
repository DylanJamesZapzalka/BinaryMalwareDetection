import angr
from angrutils import *
import networkx as nx
import numpy as np
import os
import sys
import scipy



# What family the group of binaries is apart of 
file_family = 0
# The directory containing the binaries
directory_name = "../project/data/Labeled-Elfs/group2/"
directory = os.fsencode(directory_name)
# The file where you will save the data
save_file_location = "../project/data/benign_group_2.txt"

# x86 instuction set
in_set = ['aaa', 'aad', 'aam', 'aas', 'adc', 'add', 'addpd', 'addsd', 'addss',
        'and', 'andnpd', 'andnps', 'andpd', 'andps', 'arpl', 'bsf', 'bsr', 'bswap',
        'bt', 'btc', 'btr', 'bts', 'call', 'cbw', 'cdq', 'cdqe', 'clc', 'cld',
        'cli', 'clts', 'cmc', 'cmova', 'cmovae', 'cmovb', 'cmovbe', 'cmove',
        'cmovg', 'cmovg', 'cmovge', 'cmovl', 'cmovle', 'cmovne', 'cmovns', 'cmovs',
        'cmp', 'cmpltsd', 'cmpltss', 'cmpsb', 'cmpsd', 'cmpsw', 'cmpxchg', 'cqo',
        'cvtsd2ss', 'cvtsi2sd', 'cvtsi2ss', 'cvtss2sd', 'cvttsd2si', 'cvttss2si',
        'cwd', 'cwde', 'daa', 'das', 'dec', 'div', 'divsd', 'divss', 'esc', 'fadd',
        'faddp', 'fchs', 'fcmove', 'fcmovnbe', 'fdiv', 'fdivp', 'fdivrp', 'fiadd',
        'fild', 'fistp', 'fld', 'fld1', 'fldcw', 'fldz', 'fmul', 'fmulp', 'fnstcw',
        'fstp', 'fsub', 'fsubrp', 'fucomi', 'fucomip', 'fxch', 'hlt', 'ibts',
        'idiv', 'imul', 'in', 'inc', 'insd', 'int', 'into', 'invd', 'invlpg',
        'iret', 'ja', 'jae', 'jb', 'jbe', 'jc', 'jcxz', 'je', 'jg', 'jge', 'jl',
        'jle', 'jmp', 'jna', 'jnae', 'jnb', 'jnbe', 'jnc', 'jne', 'jng', 'jnge',
        'jnl', 'jnle', 'jno', 'jnp', 'jns', 'jnz', 'jo', 'jp', 'jpe', 'jpo', 'js',
        'jz', 'lahf', 'lar', 'lds', 'lea', 'leave', 'les', 'lfs', 'lgdt', 'lgs',
        'lidt', 'lldt', 'lmsw', 'loadall', 'lock', 'lodsb', 'lodsd', 'lodsw',
        'loop', 'loopd', 'loopne', 'loopnz', 'loopz', 'lsl', 'lss', 'ltr', 'maxsd',
        'minsd', 'mov', 'movabs', 'movapd', 'movaps', 'movd', 'movdqa', 'movdqu',
        'movq', 'movsb', 'movsd', 'movss', 'movsw', 'movsx', 'movsxd', 'movupd',
        'movups', 'movzx', 'mul', 'mulsd', 'mulss', 'neg', 'nop', 'not', 'or',
        'orpd', 'orps', 'out', 'outsd', 'packuswb', 'padd', 'paddd', 'paddq',
        'pand', 'pandn', 'pcmpeqb', 'pcmpeqd', 'pcmpgtd', 'pinsrw', 'pop', 'popf',
        'popfd', 'por', 'pshufd', 'pshuflw', 'pslldq', 'psllq', 'psrad', 'psrlq',
        'psrlw', 'punpcklbw', 'punpckldq', 'punpcklqdq', 'punpcklwd', 'push',
        'pushf', 'pushfd', 'pxor', 'rcl', 'rcr', 'rep', 'repe', 'repne', 'repnz',
        'repz', 'ret', 'retf', 'retn', 'rol', 'ror', 'sahf', 'sal', 'sar', 'sbb',
        'scasb', 'scasd', 'scasw', 'seta', 'setae', 'setb', 'setbe', 'setc',
        'sete', 'setg', 'setge', 'setl', 'setle', 'setna', 'setnae', 'setnb',
        'setnbe', 'setnc', 'setne', 'setng', 'setnge', 'setns', 'setp', 'sets',
        'sgdt', 'shl', 'shld', 'shr', 'shrd', 'shufpd', 'sidt', 'sldt', 'smsw',
        'stc', 'std', 'sti', 'stosb', 'stosd', 'stosw', 'str', 'sub', 'subpd',
        'subsd', 'subss', 'test', 'ucomisd', 'ucomiss', 'verr', 'verw', 'wait',
        'wbinvd', 'xadd', 'xbts', 'xchg', 'xlat', 'xor', 'xorpd', 'xorps']



# Used to keep track of how many binaries have been processed
processed = 0
total = len(os.listdir(directory))

# Obtain the control flow graphs from the binaries
adjacency_matrices = []
graphs = []
print("CFG extraction has started...")
for file in os.listdir(directory):
    filename = os.fsdecode(file)
    try:
        proj = angr.Project(directory_name + filename, load_options={'auto_load_libs': False})
        print("Current File: " + filename)
        cfg = proj.analyses.CFGFast()
        graphs.append(cfg.graph)
        processed += 1
        print(cfg.graph)
        print(str((processed/total)*100) + "% " + "done")
    except:
        print("Failed to process file")
        processed += 1
        continue

# Obtain the features from the control flow graphs
print("Feature extraction and printing has started...")
num_graphs = len(graphs)
processed = 0
file = open(save_file_location, "w")
for graph in graphs:
    embeded_node_vectors = np.zeros((len(graph.nodes()), len(in_set)))
    nodes = list(graph.nodes())
    for i in range(len(nodes)):
        if nodes[i].block != None:
            for line in str(nodes[i].block.disassembly).splitlines():
                instruction = line.split()[1]
                try:
                    index = in_set.index(instruction)
                    embeded_node_vectors[i][index] += 1
                except:
                    print("\'" + instruction + "\' " + 
                        "was not found as a valid instruction. You should consider adding this.")
    
    # Convert the graph into a sparse matrix in scipy COOrdinate format.
    sparse = nx.adjacency_matrix(graph).tocoo()
    nodes1 = sparse.row
    nodes2 = sparse.col
    
    # Print the graph results
    file.write("G \n")

    # Print the edges
    for i in range(len(nodes1)):
        file.write(str(nodes1[i]) + " ")
    file.write("\n")
    for i in range(len(nodes2)):
        file.write(str(nodes2[i]) + " ")
    file.write("\n")

    # Print the feature vectors
    for i in range(np.shape(embeded_node_vectors)[0]):
        for j in range(np.shape(embeded_node_vectors)[1]):
            if embeded_node_vectors[i][j] != 0:
                file.write(str(j) + ":" + str(embeded_node_vectors[i][j]) + " ")
        file.write("\n")
    
    # Indicate how many graphs have been processed
    processed += 1
    print(str((processed/num_graphs)*100) + "% " + "done")

# Wrap up everything
file.close()
print("Finished!")
